<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ThermoCalc Simulations</title>
<style>
  :root { --bg:#f7f9fc; --card:#fff; --ink:#0f172a; --muted:#475569; --accent:#2563eb; --line:#e2e8f0; }
  *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.5 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial}
  header{display:flex;align-items:center;justify-content:space-between;max-width:960px;margin:32px auto 16px;padding:0 16px}
  header h1{margin:0;font-weight:800;letter-spacing:.2px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:16px;box-shadow:0 6px 24px rgba(15,23,42,.06);max-width:960px;margin:0 auto 28px;padding:24px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:24px}
  .field{display:flex;flex-direction:column;gap:6px}
  label{font-weight:600}
  input,select{appearance:none;border:1px solid var(--line);border-radius:10px;padding:10px 12px;background:#fff;font-size:16px}
  .help{color:var(--muted);font-size:14px}
  .btn{display:inline-block;background:var(--accent);color:#fff;border:none;border-radius:10px;padding:10px 14px;font-weight:700;cursor:pointer}
  table{width:100%;border-collapse:collapse;border-radius:12px;overflow:hidden}
  th,td{padding:10px 12px;border-bottom:1px solid var(--line);text-align:left}
  th{background:#f8fafc;font-weight:700}
  tfoot td{font-weight:600}
  footer{max-width:960px;margin:8px auto 40px;color:var(--muted);text-align:center}
  @media (max-width:800px){ .grid{grid-template-columns:1fr} }
</style>
</head>
<body>
  <header>
    <h1>ThermoCalc Simulations</h1>
    <nav class="help">© <span id="yr"></span> ThermoCalc Simulations</nav>
  </header>

  <section class="card">
    <h2 style="margin-top:0">Thermodynamic Calculations</h2>
    <p class="help" style="margin-top:-6px">RRHO model. Standard pressure is fixed to <b>101 325 Pa</b>.</p>

    <div class="grid" style="margin-top:8px">
      <div class="field">
        <label for="mol">Molecule</label>
        <!-- show proper subscript using the Unicode CO₂; value is plain "CO2" -->
        <select id="mol">
          <option value="CO">CO</option>
          <option value="O2">O₂</option>
          <option value="O3">O₃</option>
          <option value="NH3">NH₃</option>
        </select>
      </div>

      <div class="field">
        <label for="temp">Temperature (K)</label>
        <input id="temp" type="number" step="0.01" min="0.000001" value="298.15" />
      </div>

      <div class="field" style="align-self:end">
        <button class="btn" id="calc">Calculate</button>
      </div>
    </div>

    <div style="margin-top:20px">
      <table>
        <thead>
          <tr><th>Property</th><th>Value</th><th>Unit</th></tr>
        </thead>
        <tbody id="tbody">
          <!-- filled by JS -->
        </tbody>
      </table>
    </div>
  </section>

<script>
// ===== Physical constants (SI) =====
const R  = 8.31446261815324;   // J/(mol·K)
const kB = 1.380649e-23;       // J/K
const h  = 6.62607015e-34;     // J·s
const c  = 299792458;          // m/s
const NA = 6.02214076e23;      // 1/mol
const PI = Math.PI;
const P_STD = 1.01325e5;       // 101325 Pa fixed

// ===== Helpers: characteristic temperatures =====
function thetaFromCm1(cm1){ return (h*c*cm1*100)/kB; } // K
function thetasVib(arr){ return arr.map(thetaFromCm1); }
function thetasRotLinear(B){ return thetaFromCm1(B); }
function thetasRotNonlinear(A,B,C){ return [thetaFromCm1(A),thetaFromCm1(B),thetaFromCm1(C)]; }

// ===== Vibrational (RRHO; ZPE excluded from U by default) =====
function U_vib(T, theta_v, includeZPE){
  let sum=0, Tpos=Math.max(T,1e-12);
  for(const th of theta_v){ const x=th/Tpos, ex=Math.exp(x); sum += th/(ex-1) + (includeZPE?0.5*th:0); }
  return R*sum;
}
function Cv_vib(T, theta_v){
  let s=0, Tpos=Math.max(T,1e-12);
  for(const th of theta_v){ const x=th/Tpos, ex=Math.exp(x), d=ex-1; s += x*x*(ex/(d*d)); }
  return R*s;
}
function S_vib(T, theta_v){
  let s=0, Tpos=Math.max(T,1e-12);
  for(const th of theta_v){ const x=th/Tpos, ex=Math.exp(x); s += (x/(ex-1)) - Math.log(1-Math.exp(-x)); }
  return R*s;
}

// ===== Translational (ideal gas, molar) =====
function U_trans(T){ return 1.5*R*T; }
function Cv_trans(){ return 1.5*R; }
function S_trans(T, p_Pa, M_kg_per_mol){
  const m = M_kg_per_mol/NA; // single molecule
  const factor = Math.pow((2*PI*m*kB*T)/(h*h),1.5)*(kB*T/p_Pa)*NA;
  return R*(Math.log(factor)+2.5);
}

// ===== Exact rotational sums =====
// --- Linear rotor ---
function rotLinearExact(T, sigma, theta_r, relTol=1e-12, JmaxCap=200){
  const Tpos=Math.max(T,1e-12);
  let Z=0,M1=0,M2=0,highestJ=0;
  for(let J=0; J<=JmaxCap; J++){
    const JJ1=J*(J+1), g=(2*J+1), Etil=theta_r*JJ1, w=g*Math.exp(-Etil/Tpos);
    Z+=w; M1+=Etil*w; M2+=Etil*Etil*w; highestJ=J;
    if (w < relTol*Math.max(Z,1) && J>5) break;
  }
  const q=Z/sigma, lnq=Math.log(q), Ebar=M1/Z, varE=Math.max(0, M2/Z - Ebar*Ebar);
  const U=R*Ebar, Cv=R*(varE/(Tpos*Tpos)), S=R*lnq + U/Tpos;
  return {lnq,U,Cv,S,highestJ};
}

// --- Nonlinear rotor (spherical / symmetric / asymmetric) ---
function eigSymmetricJacobi(Ain, tol=1e-12, maxIter){
  const n=Ain.length, A=Ain.map(r=>r.slice()), iters=maxIter??(5*n*n);
  function off(){let p=0,q=1,m=0; for(let i=0;i<n;i++)for(let j=i+1;j<n;j++){const v=Math.abs(A[i][j]); if(v>m){m=v;p=i;q=j}} return {p,q,m};}
  for(let it=0; it<iters; it++){
    const {p,q,m}=off(); if(m<tol) break;
    const app=A[p][p], aqq=A[q][q], apq=A[p][q]; const phi=0.5*Math.atan2(2*apq,(aqq-app));
    const c=Math.cos(phi), s=Math.sin(phi);
    for(let k=0;k<n;k++){ const aip=A[k][p], aiq=A[k][q]; A[k][p]=c*aip - s*aiq; A[k][q]=s*aip + c*aiq; }
    for(let k=0;k<n;k++){ const apk=A[p][k], aqk=A[q][k]; A[p][k]=c*apk - s*aqk; A[q][k]=s*apk + c*aqk; }
    A[p][q]=A[q][p]=0;
  }
  const ev=new Array(n); for(let i=0;i<n;i++) ev[i]=A[i][i]; ev.sort((a,b)=>a-b); return ev;
}

function rotNonlinearExact(T, sigma, thetaA, thetaB, thetaC, relTol=1e-12, JmaxCap=120, nearlyTol=1e-8){
  const Tpos=Math.max(T,1e-12);
  const isClose=(a,b)=>Math.abs(a-b)<=nearlyTol*Math.max(1,Math.abs(a),Math.abs(b));
  const spherical = isClose(thetaA,thetaB) && isClose(thetaB,thetaC);
  const prolateSym = isClose(thetaB,thetaC) && !spherical; // A != B=C
  const oblateSym  = isClose(thetaA,thetaB) && !spherical; // C != A=B

  let Z=0,M1=0,M2=0,highestJ=0;

  if (spherical){
    const theta=(thetaA+thetaB+thetaC)/3;
    for(let J=0; J<=JmaxCap; J++){
      const Etil=theta*J*(J+1), g=(2*J+1)*(2*J+1), w=g*Math.exp(-Etil/Tpos);
      Z+=w; M1+=Etil*w; M2+=Etil*Etil*w; highestJ=J;
      if (w < relTol*Math.max(Z,1) && J>3) break;
    }
  } else if (prolateSym || oblateSym){
    if (prolateSym){
      const B=thetaB, A=thetaA, delta=A-B;
      for(let J=0; J<=JmaxCap; J++){
        const base=B*J*(J+1); let ZJ=0;
        for(let K=-J; K<=J; K++){
          const Etil=base + delta*K*K, gM=(2*J+1), w=gM*Math.exp(-Etil/Tpos);
          Z+=w; M1+=Etil*w; M2+=Etil*Etil*w; ZJ+=w;
        }
        highestJ=J; if (ZJ < relTol*Math.max(Z,1) && J>2) break;
      }
    } else {
      const B=thetaA, C=thetaC, delta=C-B; // A=B≈thetaA
      for(let J=0; J<=JmaxCap; J++){
        const base=B*J*(J+1); let ZJ=0;
        for(let K=-J; K<=J; K++){
          const Etil=base + delta*K*K, gM=(2*J+1), w=gM*Math.exp(-Etil/Tpos);
          Z+=w; M1+=Etil*w; M2+=Etil*Etil*w; ZJ+=w;
        }
        highestJ=J; if (ZJ < relTol*Math.max(Z,1) && J>2) break;
      }
    }
  } else {
    // asymmetric: build (2J+1)x(2J+1) matrix and diagonalize
    for(let J=0; J<=JmaxCap; J++){
      const n=2*J+1; if (n<=0) continue;
      const H=Array.from({length:n},()=>new Array(n).fill(0));
      for(let K=-J; K<=J; K++){
        const idx=K+J;
        H[idx][idx] = 0.5*(thetaA+thetaB)*(J*(J+1)-K*K) + thetaC*K*K;
      }
      const pref=0.25*(thetaA-thetaB);
      for(let K=-J; K<=J-2; K++){
        const idx=K+J, idx2=(K+2)+J;
        const f=Math.sqrt((J-K)*(J+K+1)*(J-K-1)*(J+K+2));
        const val=pref*f; H[idx][idx2]+=val; H[idx2][idx]+=val;
      }
      const evals=eigSymmetricJacobi(H), gM=(2*J+1); let ZJ=0;
      for(const Etil of evals){ const w=gM*Math.exp(-Etil/Tpos); Z+=w; M1+=Etil*w; M2+=Etil*Etil*w; ZJ+=w; }
      highestJ=J; if (ZJ < relTol*Math.max(Z,1) && J>2) break;
    }
  }

  const q=Z/sigma, lnq=Math.log(q), Ebar=M1/Z, varE=Math.max(0, M2/Z - Ebar*Ebar);
  const U=R*Ebar, Cv=R*(varE/(Tpos*Tpos)), S=R*lnq + U/Tpos;
  return {lnq:lnq,U:U,Cv:Cv,S:S,highestJ};
}

// ===== Master: assemble Cp, Cv, S, U, H =====
function thermoRRHO(mol, T, opts={}){
  const p = P_STD;
  const includeZPE = !!opts.includeZPEinU;
  const relTol = opts.rotRelTol ?? 1e-12;
  const JcapLin = opts.rotJmaxCapLinear ?? 200;
  const JcapNon = opts.rotJmaxCapNonlin ?? 120;
  const nearlyTol = opts.nearlyTol ?? 1e-8;

  const theta_v = thetasVib(mol.vib_cm1);
  const Uv  = U_vib(T, theta_v, includeZPE);
  const Cvv = Cv_vib(T, theta_v);
  const Sv  = S_vib(T, theta_v);

  const Ut = U_trans(T);
  const Cvt = Cv_trans();
  const St = S_trans(T, p, mol.M_kg_per_mol);

  let Ur=0,Cvr=0,Sr=0;
  if (mol.kind === "linear") {
    const theta_r = thetasRotLinear(mol.Brot_cm1);
    const rot = rotLinearExact(T, mol.sigma, theta_r, relTol, JcapLin);
    Ur=rot.U; Cvr=rot.Cv; Sr=rot.S;
  } else {
    const [tA,tB,tC]=thetasRotNonlinear(mol.A_cm1, mol.B_cm1, mol.C_cm1);
    const rot = rotNonlinearExact(T, mol.sigma, tA,tB,tC, relTol, JcapNon, nearlyTol);
    Ur=rot.U; Cvr=rot.Cv; Sr=rot.S;
  }

  const U  = Ut + Ur + Uv;
  const Cv = Cvt + Cvr + Cvv;
  const Cp = Cv + R;     // ideal gas
  const S  = St + Sr + Sv;
  const H  = U + R*T;

  return { Cp, Cv, S, U, H };
}

// ===== Example dataset =====
const molecules = {
  CO:  { name:"CO",  kind:"linear",    M_kg_per_mol:0.02801, sigma:1, Brot_cm1:1.92253,  vib_cm1:[2143] },
  O2: { name:"O2", kind:"linear",    M_kg_per_mol:0.031999, sigma:2, Brot_cm1:1.43768, vib_cm1:[1556] },
  O3: { name:"O3", kind:"nonlinear", M_kg_per_mol:0.047997, sigma:2, A_cm1:3.55348, B_cm1:0.44525, C_cm1:0.39479, vib_cm1:[1110,705,1042] },
  NH3: { name:"NH3", kind:"nonlinear", M_kg_per_mol:0.0170306, sigma:3, A_cm1:9.4443, B_cm1:9.4443, C_cm1:6.196, vib_cm1:[3337,950,3444,1627] },
};

// ===== UI wiring =====
const yrEl = document.getElementById('yr'); yrEl.textContent = new Date().getFullYear();
const molSel = document.getElementById('mol');
const tempEl = document.getElementById('temp');
const calcBtn = document.getElementById('calc');
const tbody = document.getElementById('tbody');

function format(num, digits=3){ return Number(num).toFixed(digits); }

function computeAndRender(){
  const key = molSel.value;
  const T = parseFloat(tempEl.value);
  const mol = molecules[key];
  if (!mol || !(T>0)) return;

  const r = thermoRRHO(mol, T, {});
  const rows = [
    ["Cp", `${format(r.Cp,3)}`, "J/(mol·K)"],
    ["Cv", `${format(r.Cv,3)}`, "J/(mol·K)"],
    ["S" , `${format(r.S ,3)}`, "J/(mol·K)"],
    ["U" , `${format(r.U ,3)}`, "J/mol"],
    ["H" , `${format(r.H ,3)}`, "J/mol"],
  ];

  tbody.innerHTML = rows.map(([k,v,u]) => `<tr><td><b>${k}</b></td><td>${v}</td><td>${u}</td></tr>`).join("");
}

calcBtn.addEventListener('click', computeAndRender);
window.addEventListener('DOMContentLoaded', computeAndRender);
</script>
</body>
</html>
